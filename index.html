
<!DOCTYPE html>
<html>
<head>
    <title>Ableton Metrolink</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
    <!-- 
    Timing Synchronization Implementation:
    - Uses Web Audio API instead of HTML5 Audio for lower latency
    - Implements look-ahead scheduling for precise timing
    - Calculates server-client time offset for synchronization
    - Provides user-adjustable timing offset for fine-tuning
    -->
    <!-- Audio cache disabled to reduce memory usage -->
    <!-- <script src="audio-cache.js"></script> -->
</head>
<body>
    <div class="container">
        <h1>Ableton Metrolink</h1>
        <div id="status">Connecting...</div>

        <div id="metronome">
            <div class="beat-pulse"></div>
            <div id="position">1.1</div>
            <div id="bpm">120 BPM</div>
        </div>

        <div class="beat-indicators">
            <div class="beat-indicator downbeat" id="beat1"></div>
            <div class="beat-indicator" id="beat2"></div>
            <div class="beat-indicator" id="beat3"></div>
            <div class="beat-indicator" id="beat4"></div>
        </div>

        <div class="controls">
            <button id="startBtn" onclick="sendCommand('start')">▶ Start</button>
            <button id="stopBtn" onclick="sendCommand('stop')" disabled>⏹ Stop</button>
        </div>
        
        <div class="settings-container">
            <button id="settingsToggle" class="settings-toggle" onclick="toggleSettings(); return false;">
                ⚙️ Settings
            </button>
            
            <div class="sound-controls" id="settingsPanel" style="display: none;">
                <div class="settings-header">
                    <h3>Settings</h3>
                    <button id="closeSettings" class="close-settings" onclick="hideSettings(); return false;">×</button>
                </div>
                
                <div class="settings-section">
                    <h4>Appearance</h4>
                    <div class="theme-toggle">
                        <label for="themeSwitch">Dark Theme:</label>
                        <label class="theme-switch">
                            <input type="checkbox" id="themeSwitch">
                            <span class="slider">
                                <span class="icon sun">☀️</span>
                                <span class="icon moon">🌙</span>
                            </span>
                        </label>
                    </div>
                    
                    <div class="fullscreen-toggle">
                        <label for="fullscreenBtn">Fullscreen:</label>
                        <button id="fullscreenBtn">⛶ Enter Fullscreen</button>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h4>Sound Settings</h4>
                    <div class="sound-option">
                        <label for="clickSound">Click Sound:</label>
                        <select id="clickSound">
                            <option value="click1">Standard Click</option>
                            <option value="click2">Wooden Click</option>
                            <option value="click3">Digital Click</option>
                        </select>
                    </div>
                    
                    <div class="volume-control">
                        <label for="volume">Volume:</label>
                        <input type="range" id="volume" min="0" max="1" step="0.1" value="0.5">
                    </div>
                    
                    <div class="mute-control">
                        <label for="muteBtn">Sound:</label>
                        <button id="muteBtn" class="muted">🔇 Off</button>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h4>Timing Settings</h4>
                    <div class="timing-control">
                        <label for="latencyOffset">Timing Offset (ms):</label>
                        <input type="range" id="latencyOffset" min="-100" max="100" step="5" value="50">
                        <span id="offsetValue">50 ms</span>
                    </div>
                </div>
                
                <div class="settings-section">
                    <h4>Performance Monitoring</h4>
                    <div class="debug-toggle">
                        <label for="debugSwitch">Show Debug Info:</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="debugSwitch">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                    
                    <div id="debugPanel" style="display: none;">
                        <div class="debug-metrics">
                            <div class="metric">
                                <span class="metric-label">Scheduled Beats:</span>
                                <span class="metric-value" id="scheduledBeats">0</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Played Beats:</span>
                                <span class="metric-value" id="playedBeats">0</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Missed Beats:</span>
                                <span class="metric-value" id="missedBeats">0</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Avg. Latency:</span>
                                <span class="metric-value" id="avgLatency">0 ms</span>
                            </div>
                            <div class="metric">
                                <span class="metric-label">Server Offset:</span>
                                <span class="metric-value" id="serverOffset">0 ms</span>
                            </div>
                        </div>
                        <button id="resetMetricsBtn" class="debug-button">Reset Metrics</button>
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <script>
        // Service worker disabled to reduce memory usage
        // if ('serviceWorker' in navigator) {
        //     window.addEventListener('load', () => {
        //         navigator.serviceWorker.register('/service-worker.js')
        //             .then(registration => {
        //                 console.log('Service Worker registered with scope:', registration.scope);
        //             })
        //             .catch(error => {
        //                 console.error('Service Worker registration failed:', error);
        //             });
        //     });
        // }
        
        // Optimized mobile version and iOS detection
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        const updateInterval = isMobile ? 100 : 50;

        const metronome = document.getElementById('metronome');
        const positionDisplay = document.getElementById('position');
        const bpmDisplay = document.getElementById('bpm');
        const statusDisplay = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const beatIndicators = [
            document.getElementById('beat1'),
            document.getElementById('beat2'),
            document.getElementById('beat3'),
            document.getElementById('beat4')
        ];
        
        // Sound controls
        const clickSoundSelect = document.getElementById('clickSound');
        const volumeControl = document.getElementById('volume');
        const muteBtn = document.getElementById('muteBtn');
        
        // Web Audio API context
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Sound types for oscillator-based click sounds
        // No need to load audio files, we generate sounds programmatically
        
        // Sound settings
        let soundSettings = {
            currentSound: 'click1',
            volume: 0.5,
            muted: true, // Muted by default
            lastBeat: null,
            latencyOffset: 0.05  // 50ms default latency compensation
        };

        let currentData = {
            position: "1.1",
            bpm: 120,
            is_downbeat: false,
            transport_running: false,
            timestamp: 0
        };
        
        // Scheduling variables
        let scheduledBeats = [];
        // Adaptive look-ahead time based on device capabilities
        let lookAheadTime = isMobile ? 0.3 : 0.2;  // Longer look-ahead for mobile (300ms vs 200ms)
        let scheduleInterval = isMobile ? 40 : 50;  // More frequent checks on mobile (40ms vs 50ms)
        let lastScheduleTime = 0;
        let serverTimeOffset = 0;  // Difference between server and client time
        
        // Audio source pool removed - using simpler oscillator-based sound generation
        
        // Performance metrics for timing accuracy
        const timingMetrics = {
            scheduledBeats: 0,
            playedBeats: 0,
            missedBeats: 0,
            totalLatency: 0,
            measurements: 0,
            
            // Add a latency measurement
            addLatencyMeasurement(latency) {
                this.totalLatency += latency;
                this.measurements++;
            },
            
            // Get average latency
            getAverageLatency() {
                return this.measurements > 0 ? this.totalLatency / this.measurements : 0;
            },
            
            // Reset metrics
            reset() {
                this.scheduledBeats = 0;
                this.playedBeats = 0;
                this.missedBeats = 0;
                this.totalLatency = 0;
                this.measurements = 0;
            }
        };
        
        let lastUpdate = 0;
        let socket;
        let scheduleTimer;

        // Mock server mode flag
        let useMockServer = false;
        let mockServerTimer = null;
        let mockBPM = 120;
        let mockBar = 1;
        let mockBeat = 1;
        let mockTransportRunning = false;
        
        // Global fallback timer to force mock server mode if connection hangs
        let globalFallbackTimer = null;

        function connectWebSocket() {
            try {
                // Check if we should use mock server mode
                if (localStorage.getItem('useMockServer') === 'true') {
                    useMockServer = true;
                }
                
                // If mock server mode is enabled, use that instead of WebSocket
                if (useMockServer) {
                    console.log('Using mock server mode');
                    setupMockServer();
                    return;
                }
                
                const serverIP = window.location.hostname || 'localhost';
                socket = new WebSocket(`ws://${serverIP}:8765`);
                
                // Set a connection timeout - reduced to 3 seconds for faster fallback
                const connectionTimeout = setTimeout(() => {
                    if (socket.readyState !== WebSocket.OPEN) {
                        console.log('WebSocket connection timeout - switching to mock server mode');
                        try {
                            socket.close();
                        } catch (e) {
                            console.error('Error closing socket:', e);
                        }
                        useMockServer = true;
                        localStorage.setItem('useMockServer', 'true');
                        setupMockServer();
                    }
                }, 3000); // 3 second timeout

                socket.onopen = () => {
                    clearTimeout(connectionTimeout);
                    statusDisplay.textContent = '✅ Połączono z serwerem MIDI';
                    statusDisplay.className = '';
                    console.log('Połączenie WebSocket otwarte');
                };

                socket.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log("Received MIDI update:", data);

                        // Filtruj nierealne wartości
                        if (data.bpm < 20 || data.bpm > 300) {
                            console.warn("Unrealistic BPM value:", data.bpm);
                            return;
                        }
                        
                        // Calculate server-client time offset
                        const clientTime = performance.now() / 1000;  // Convert to seconds
                        const serverTime = data.timestamp;
                        
                        // Update time offset with smoothing
                        if (serverTimeOffset === 0) {
                            serverTimeOffset = serverTime - clientTime;
                        } else {
                            // Gradually adjust the offset (90% old, 10% new)
                            serverTimeOffset = 0.9 * serverTimeOffset + 0.1 * (serverTime - clientTime);
                        }

                        // Aktualizuj tylko jeśli dane się zmieniły lub minął określony czas
                        if (data.position !== currentData.position ||
                            performance.now() - lastUpdate >= updateInterval) {

                            lastUpdate = performance.now();

                            // Update BPM immediately for better responsiveness
                            // Removed excessive smoothing that was causing delays
                            currentData.bpm = data.bpm;

                            // Aktualizacja pozostałych danych
                            currentData.position = data.position;
                            currentData.is_downbeat = data.is_downbeat;
                            currentData.transport_running = data.transport_running;
                            currentData.timestamp = data.timestamp;

                            // Wymuś natychmiastową aktualizację UI
                            updateUI();
                            
                            // Start or stop the scheduler based on transport state
                            if (currentData.transport_running && !scheduleTimer) {
                                try {
                                    await startScheduler();
                                } catch (schedulerError) {
                                    console.error('Error starting scheduler:', schedulerError);
                                }
                            } else if (!currentData.transport_running && scheduleTimer) {
                                stopScheduler();
                            }
                        }
                    } catch (error) {
                        console.error('Błąd przetwarzania danych MIDI:', error);
                    }
                };

                socket.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    console.error('Błąd WebSocket:', error);
                    statusDisplay.textContent = '❌ Błąd połączenia z serwerem';
                    statusDisplay.className = 'status-error';
                    
                    // Switch to mock server mode after error
                    setTimeout(() => {
                        useMockServer = true;
                        localStorage.setItem('useMockServer', 'true');
                        setupMockServer();
                    }, 1000);
                };

                socket.onclose = () => {
                    clearTimeout(connectionTimeout);
                    console.log('Połączenie WebSocket zamknięte');
                    
                    // Only show reconnection message if not switching to mock server
                    if (!useMockServer) {
                        statusDisplay.textContent = '❌ Połączenie zamknięte - próba ponownego połączenia...';
                        statusDisplay.className = 'status-error';
                        setTimeout(connectWebSocket, 3000);
                    }
                };
            } catch (error) {
                console.error('Error in connectWebSocket:', error);
                useMockServer = true;
                localStorage.setItem('useMockServer', 'true');
                setupMockServer();
            }
        }
        
        // Setup mock server functionality
        function setupMockServer() {
            statusDisplay.textContent = '🔄 Tryb lokalny (bez serwera)';
            statusDisplay.className = '';
            console.log('Mock server mode activated');
            
            // Create mock server controls container
            const mockServerControls = document.createElement('div');
            mockServerControls.style.marginTop = '15px';
            mockServerControls.style.padding = '10px';
            mockServerControls.style.backgroundColor = '#f8f9fa';
            mockServerControls.style.borderRadius = '5px';
            mockServerControls.style.border = '1px solid #ddd';
            mockServerControls.style.display = 'flex';
            mockServerControls.style.flexDirection = 'column';
            mockServerControls.style.gap = '10px';
            
            // Add a title for the mock server controls
            const mockServerTitle = document.createElement('div');
            mockServerTitle.textContent = 'Ustawienia trybu lokalnego';
            mockServerTitle.style.fontWeight = 'bold';
            mockServerTitle.style.marginBottom = '5px';
            mockServerControls.appendChild(mockServerTitle);
            
            // Add BPM control
            const bpmControlContainer = document.createElement('div');
            bpmControlContainer.style.display = 'flex';
            bpmControlContainer.style.alignItems = 'center';
            bpmControlContainer.style.gap = '10px';
            
            const bpmLabel = document.createElement('label');
            bpmLabel.textContent = 'BPM:';
            bpmLabel.style.minWidth = '50px';
            bpmLabel.style.textAlign = 'right';
            
            const bpmInput = document.createElement('input');
            bpmInput.type = 'range';
            bpmInput.min = '60';
            bpmInput.max = '200';
            bpmInput.step = '1';
            bpmInput.value = mockBPM.toString();
            bpmInput.style.flex = '1';
            
            const bpmValue = document.createElement('span');
            bpmValue.textContent = mockBPM.toString();
            bpmValue.style.minWidth = '40px';
            bpmValue.style.textAlign = 'center';
            bpmValue.style.backgroundColor = '#f0f0f0';
            bpmValue.style.padding = '2px 5px';
            bpmValue.style.borderRadius = '3px';
            bpmValue.style.border = '1px solid #ddd';
            
            bpmInput.oninput = () => {
                const newBPM = parseInt(bpmInput.value);
                mockBPM = newBPM;
                bpmValue.textContent = newBPM.toString();
                currentData.bpm = newBPM;
                
                // Update UI
                updateUI();
                
                // If the mock server timer is running, restart it with the new BPM
                if (mockServerTimer) {
                    clearInterval(mockServerTimer);
                    const beatInterval = 60000 / mockBPM; // ms per beat
                    mockServerTimer = setInterval(mockServerTick, beatInterval);
                    console.log(`Updated mock server BPM to ${mockBPM}, new interval: ${beatInterval}ms`);
                }
            };
            
            bpmControlContainer.appendChild(bpmLabel);
            bpmControlContainer.appendChild(bpmInput);
            bpmControlContainer.appendChild(bpmValue);
            mockServerControls.appendChild(bpmControlContainer);
            
            // Add a button to toggle between mock and real server
            const toggleServerBtn = document.createElement('button');
            toggleServerBtn.textContent = 'Przełącz na serwer rzeczywisty';
            toggleServerBtn.style.marginTop = '10px';
            toggleServerBtn.style.padding = '5px 10px';
            toggleServerBtn.style.fontSize = '0.9rem';
            toggleServerBtn.style.backgroundColor = '#f0f0f0';
            toggleServerBtn.style.border = '1px solid #ccc';
            toggleServerBtn.style.borderRadius = '3px';
            toggleServerBtn.style.cursor = 'pointer';
            toggleServerBtn.style.alignSelf = 'center';
            
            toggleServerBtn.onclick = () => {
                useMockServer = false;
                localStorage.setItem('useMockServer', 'false');
                if (mockServerTimer) {
                    clearInterval(mockServerTimer);
                    mockServerTimer = null;
                }
                statusDisplay.textContent = 'Łączenie z serwerem...';
                mockServerControls.remove();
                connectWebSocket();
            };
            
            mockServerControls.appendChild(toggleServerBtn);
            
            // Add the controls below the status display
            statusDisplay.parentNode.insertBefore(mockServerControls, statusDisplay.nextSibling);
            
            // Initialize mock data
            currentData.bpm = mockBPM;
            currentData.position = `${mockBar}.${mockBeat}`;
            currentData.is_downbeat = mockBeat === 1;
            currentData.transport_running = mockTransportRunning;
            currentData.timestamp = performance.now() / 1000;
            
            updateUI();
        }
        
        // Function to simulate MIDI clock in mock server mode
        function mockServerTick() {
            if (!mockTransportRunning) return;
            
            // Update beat and bar
            mockBeat++;
            if (mockBeat > 4) {
                mockBeat = 1;
                mockBar++;
            }
            
            // Update current data
            currentData.position = `${mockBar}.${mockBeat}`;
            currentData.is_downbeat = mockBeat === 1;
            currentData.timestamp = performance.now() / 1000;
            
            // Update UI
            updateUI();
            
            // Handle scheduling
            if (mockTransportRunning && !scheduleTimer) {
                startScheduler();
            }
        }

        function updateUI() {
            // Aktualizacja wyświetlania
            positionDisplay.textContent = currentData.position;
            bpmDisplay.textContent = `${Math.round(currentData.bpm)} BPM`;

            // Aktualizacja wskaźników beatów
            const [bar, beat] = currentData.position.split('.').map(Number);
            const beatIndex = beat - 1;

            beatIndicators.forEach((indicator, index) => {
                const isActive = index === beatIndex;
                indicator.classList.toggle('active', isActive);
                indicator.classList.toggle('downbeat', isActive && currentData.is_downbeat);
            });

            // Aktualizacja pulsu metronomu
            metronome.classList.remove('downbeat', 'beat');
            if (beatIndex >= 0) {
                metronome.classList.add(currentData.is_downbeat ? 'downbeat' : 'beat');
                
                // Update the last beat and play sound as a final fallback
                const currentBeat = `${bar}.${beat}`;
                if (currentData.transport_running && currentBeat !== soundSettings.lastBeat) {
                    // Play sound directly as a fallback
                    playClickSound(currentData.is_downbeat, 0).catch(error => {
                        console.error(`Error playing sound for beat ${currentBeat}:`, error);
                    });
                    
                    soundSettings.lastBeat = currentBeat;
                }
            }

            // Aktualizacja stanu przycisków
            startBtn.disabled = currentData.transport_running;
            stopBtn.disabled = !currentData.transport_running;
        }
        
        // Start the scheduler
        async function startScheduler() {
            if (scheduleTimer) return; // Already running
            
            console.log('Starting beat scheduler...');
            
            // Try to ensure audio context is running before starting scheduler
            if (audioContext.state === 'suspended') {
                try {
                    console.log('Audio context suspended before starting scheduler, attempting to resume...');
                    await audioContext.resume();
                    console.log('Audio context resumed before starting scheduler');
                } catch (resumeError) {
                    console.error('Failed to resume audio context before starting scheduler:', resumeError);
                    // Continue anyway, we'll try again in scheduleNextBeat
                }
            }
            
            // Schedule the next beat immediately
            await scheduleNextBeat();
            
            // Set up the scheduler to run at regular intervals
            scheduleTimer = setInterval(async () => {
                await scheduleNextBeat();
            }, scheduleInterval);
            
            console.log('Beat scheduler started. Audio context state:', audioContext.state);
        }
        
        // Stop the scheduler
        function stopScheduler() {
            if (scheduleTimer) {
                clearInterval(scheduleTimer);
                scheduleTimer = null;
                scheduledBeats = [];
                console.log('Beat scheduler stopped');
            }
        }
        
        // Schedule the next beat - simplified for better performance
        async function scheduleNextBeat() {
            if (!currentData.transport_running) {
                return;
            }
            
            try {
                // Get current time in the audio context
                const currentTime = audioContext.currentTime;
                
                // Get the current beat position
                const [bar, beat] = currentData.position.split('.').map(Number);
                const currentBeatId = `${bar}.${beat}`;
                
                // Check if this beat is already scheduled
                if (scheduledBeats.some(b => b.id === currentBeatId)) {
                    return;
                }
                
                // Track this beat in metrics
                timingMetrics.scheduledBeats++;
                
                // Simplified beat time calculation
                // Start with server timestamp and apply latency offset
                let beatTime = (currentData.timestamp - serverTimeOffset) + soundSettings.latencyOffset;
                
                // Ensure the beat time is in the future with enough lead time
                const minimumLeadTime = isMobile ? 0.15 : 0.1; // 150ms for mobile, 100ms for desktop
                
                if (beatTime <= currentTime + minimumLeadTime) {
                    // If the calculated time doesn't have enough lead time, adjust it
                    beatTime = currentTime + minimumLeadTime;
                    timingMetrics.missedBeats++;
                }
                
                // Schedule if the beat is in the future and within our look-ahead window
                if (beatTime > currentTime && beatTime < currentTime + lookAheadTime) {
                    // Try to ensure audio context is running
                    if (audioContext.state === 'suspended') {
                        try {
                            await audioContext.resume();
                        } catch (resumeError) {
                            console.error('Failed to resume audio context:', resumeError);
                        }
                    }
                    
                    // Schedule the sound
                    const soundPlayed = await playClickSound(currentData.is_downbeat, beatTime);
                    
                    // Add to scheduled beats with minimal metadata
                    scheduledBeats.push({
                        id: currentBeatId,
                        time: beatTime,
                        isDownbeat: currentData.is_downbeat
                    });
                    
                    if (soundPlayed) {
                        timingMetrics.playedBeats++;
                    }
                    
                    // Clean up old scheduled beats
                    scheduledBeats = scheduledBeats.filter(beat => beat.time > currentTime - 1);
                } else {
                    timingMetrics.missedBeats++;
                }
            } catch (error) {
                console.error('Error in scheduleNextBeat:', error);
            }
        }
        
        // Function to play click sound using oscillators (more efficient than sample-based audio)
        async function playClickSound(isDownbeat, scheduleTime = 0) {
            if (soundSettings.muted) {
                return false;
            }
            
            try {
                // Check audio context state and try to resume if suspended
                if (audioContext.state === 'suspended') {
                    try {
                        await audioContext.resume();
                    } catch (resumeError) {
                        console.error('Failed to resume audio context:', resumeError);
                        return false;
                    }
                }
                
                if (audioContext.state !== 'running') {
                    return false;
                }
                
                // Get the actual time to play the sound
                const playTime = scheduleTime > 0 ? scheduleTime : audioContext.currentTime;
                
                // Define sound parameters based on the selected click type
                let frequency, duration, attackTime, releaseTime;
                
                switch (soundSettings.currentSound) {
                    case 'click1': // Standard click
                        frequency = isDownbeat ? 1800 : 1200;
                        duration = 0.03;
                        attackTime = 0.001;
                        releaseTime = 0.01;
                        break;
                    case 'click2': // Wooden click
                        frequency = isDownbeat ? 2200 : 1600;
                        duration = 0.04;
                        attackTime = 0.002;
                        releaseTime = 0.02;
                        break;
                    case 'click3': // Digital click
                        frequency = isDownbeat ? 1500 : 1000;
                        duration = 0.02;
                        attackTime = 0.001;
                        releaseTime = 0.008;
                        break;
                    default:
                        frequency = isDownbeat ? 1800 : 1200;
                        duration = 0.03;
                        attackTime = 0.001;
                        releaseTime = 0.01;
                }
                
                // Create oscillator
                const oscillator = audioContext.createOscillator();
                oscillator.type = 'sine';
                oscillator.frequency.value = frequency;
                
                // Create gain node for envelope and volume control
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0;
                
                // Apply volume setting
                const volumeNode = audioContext.createGain();
                volumeNode.gain.value = soundSettings.volume;
                
                // Connect nodes
                oscillator.connect(gainNode);
                gainNode.connect(volumeNode);
                volumeNode.connect(audioContext.destination);
                
                // Schedule envelope
                const startTime = playTime;
                const attackEndTime = startTime + attackTime;
                const releaseStartTime = attackEndTime + duration;
                const releaseEndTime = releaseStartTime + releaseTime;
                
                // Attack
                gainNode.gain.setValueAtTime(0, startTime);
                gainNode.gain.linearRampToValueAtTime(1, attackEndTime);
                
                // Sustain
                gainNode.gain.setValueAtTime(1, releaseStartTime);
                
                // Release
                gainNode.gain.linearRampToValueAtTime(0, releaseEndTime);
                
                // Start and stop the oscillator
                oscillator.start(startTime);
                oscillator.stop(releaseEndTime);
                
                // Clean up after playback
                oscillator.onended = () => {
                    oscillator.disconnect();
                    gainNode.disconnect();
                    volumeNode.disconnect();
                };
                
                return true;
            } catch (error) {
                console.error('Error in playClickSound:', error);
                return false;
            }
        }
        
        // Event listeners for sound controls are defined later with saveSettings functionality
        
        
        // Latency offset control
        const latencyOffsetControl = document.getElementById('latencyOffset');
        const offsetValueDisplay = document.getElementById('offsetValue');
        
        latencyOffsetControl.addEventListener('input', () => {
            const offsetMs = parseInt(latencyOffsetControl.value);
            soundSettings.latencyOffset = offsetMs / 1000; // Convert ms to seconds
            offsetValueDisplay.textContent = `${offsetMs} ms`;
            
            // Log the change
            console.log(`Latency offset set to ${offsetMs} ms`);
        });

        function sendCommand(type) {
            if (useMockServer) {
                // Handle commands in mock server mode
                console.log(`Mock server command: ${type}`);
                
                if (type === 'start') {
                    mockTransportRunning = true;
                    currentData.transport_running = true;
                    
                    // Reset counters if needed
                    if (!mockServerTimer) {
                        mockBar = 1;
                        mockBeat = 1;
                        currentData.position = `${mockBar}.${mockBeat}`;
                        currentData.is_downbeat = true;
                        currentData.timestamp = performance.now() / 1000;
                        
                        // Start the mock server timer to simulate MIDI clock
                        const beatInterval = 60000 / mockBPM; // ms per beat
                        mockServerTimer = setInterval(mockServerTick, beatInterval);
                        
                        console.log(`Started mock server with BPM: ${mockBPM}, interval: ${beatInterval}ms`);
                    }
                    
                    updateUI();
                    
                    // Start the scheduler
                    if (!scheduleTimer) {
                        startScheduler();
                    }
                } else if (type === 'stop') {
                    mockTransportRunning = false;
                    currentData.transport_running = false;
                    
                    // Stop the mock server timer
                    if (mockServerTimer) {
                        clearInterval(mockServerTimer);
                        mockServerTimer = null;
                    }
                    
                    updateUI();
                    
                    // Stop the scheduler
                    if (scheduleTimer) {
                        stopScheduler();
                    }
                }
                
                return;
            }
            
            // Real server mode
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type }));
                console.log(`Wysłano komendę: ${type}`);
            } else {
                console.error('Połączenie WebSocket nie jest otwarte');
                
                // Fallback to mock server if real server is not available
                useMockServer = true;
                localStorage.setItem('useMockServer', 'true');
                setupMockServer();
                
                // Retry the command with mock server
                setTimeout(() => sendCommand(type), 100);
            }
        }

        // Resume audio context on user interaction (required by browsers, especially iOS)
        function resumeAudioContext() {
            console.log('User interaction detected, audio context state:', audioContext.state);
            
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('AudioContext resumed after user interaction');
                    
                    // Play a silent sound to fully activate audio
                    playSilentSound();
                    
                    // For iOS, we need to unlock audio elements as well
                    if (isIOS) {
                        unlockIOSAudio();
                    }
                }).catch(error => {
                    console.error('Error resuming AudioContext:', error);
                    
                    // If Web Audio API fails, try to at least unlock HTML5 Audio on iOS
                    if (isIOS) {
                        unlockIOSAudio();
                    }
                });
            } else {
                // Even if the context is running, play a silent sound to ensure activation
                playSilentSound();
                
                // For iOS, we need to unlock audio elements as well
                if (isIOS) {
                    unlockIOSAudio();
                }
            }
        }
        
        // Play a silent sound to help activate the audio context
        function playSilentSound() {
            try {
                // Create a short silent buffer
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.start(0);
                console.log('Silent sound played to activate audio context');
            } catch (error) {
                console.error('Error playing silent sound:', error);
            }
        }
        
        // Unlock audio on iOS devices using oscillators
        function unlockIOSAudio() {
            console.log('Attempting to unlock iOS audio...');
            
            try {
                // Create a short silent oscillator
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                // Set the gain to 0 to make it silent
                gainNode.gain.value = 0;
                
                // Connect the oscillator to the gain node and the gain node to the destination
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Start and stop the oscillator immediately
                oscillator.start(0);
                oscillator.stop(0.1);
                
                console.log('Attempted to unlock iOS audio with oscillator');
            } catch (e) {
                console.error('Error unlocking iOS audio:', e);
            }
        }
        
        // Add event listeners to resume audio context
        document.addEventListener('click', resumeAudioContext);
        document.addEventListener('touchstart', resumeAudioContext);
        
        // Audio will be muted by default and can be enabled through settings
        
        // Settings panel toggle functionality
        const settingsToggle = document.getElementById('settingsToggle');
        const settingsPanel = document.getElementById('settingsPanel');
        const closeSettings = document.getElementById('closeSettings');
        
        console.log('Settings elements:', {
            settingsToggle: settingsToggle,
            settingsPanel: settingsPanel,
            closeSettings: closeSettings
        });
        
        // Function to show settings panel
        function showSettings() {
            console.log('Showing settings panel');
            try {
                if (!settingsPanel) {
                    console.error('Settings panel element not found in showSettings');
                    return;
                }
                
                // Force display to flex
                settingsPanel.style.display = 'flex';
                
                // Double-check that it worked
                setTimeout(() => {
                    if (getComputedStyle(settingsPanel).display === 'none') {
                        console.warn('Settings panel still hidden after showSettings, forcing display again');
                        settingsPanel.style.cssText = 'display: flex !important';
                    } else {
                        console.log('Settings panel is now visible');
                    }
                }, 50);
                
                // Save state to localStorage
                localStorage.setItem('settingsOpen', 'true');
            } catch (error) {
                console.error('Error in showSettings:', error);
            }
        }
        
        // Function to hide settings panel
        function hideSettings() {
            console.log('Hiding settings panel');
            try {
                if (!settingsPanel) {
                    console.error('Settings panel element not found in hideSettings');
                    return;
                }
                
                // Force display to none
                settingsPanel.style.display = 'none';
                
                // Save state to localStorage
                localStorage.setItem('settingsOpen', 'false');
            } catch (error) {
                console.error('Error in hideSettings:', error);
            }
        }
        
        // Toggle settings panel when button is clicked (backup event listener)
        if (settingsToggle) {
            settingsToggle.addEventListener('click', (e) => {
                console.log('Settings toggle clicked via event listener');
                e.preventDefault(); // Prevent any default behavior
                
                try {
                    // More robust check for display state
                    const isHidden = settingsPanel.style.display === 'none' || 
                                     getComputedStyle(settingsPanel).display === 'none' ||
                                     !settingsPanel.offsetParent;
                    
                    console.log('Settings panel is hidden (event listener check):', isHidden);
                    
                    if (isHidden) {
                        showSettings();
                    } else {
                        hideSettings();
                    }
                } catch (error) {
                    console.error('Error in settings toggle event listener:', error);
                }
            });
            console.log('Added click event listener to settings toggle button');
        } else {
            console.error('Settings toggle button not found');
        }
        
        // Close settings when close button is clicked (backup event listener)
        if (closeSettings) {
            closeSettings.addEventListener('click', (e) => {
                console.log('Close settings button clicked via event listener');
                e.preventDefault(); // Prevent any default behavior
                hideSettings();
            });
            console.log('Added click event listener to close settings button');
        } else {
            console.error('Close settings button not found');
        }
        
        // Force initialize settings panel display state
        if (settingsPanel) {
            // Ensure the initial state is explicitly set
            settingsPanel.style.display = 'none';
            console.log('Initialized settings panel display state to none');
        } else {
            console.error('Settings panel not found during initial display state setup');
        }
        
        // Global function for direct onclick handler
        function toggleSettings() {
            console.log('toggleSettings function called directly');
            
            try {
                if (!settingsPanel) {
                    console.error('Settings panel not found in toggleSettings function');
                    // Try to get it again in case it wasn't available earlier
                    const panelElement = document.getElementById('settingsPanel');
                    if (!panelElement) {
                        console.error('Settings panel still not found after retry');
                        return;
                    }
                    console.log('Settings panel found on retry');
                    // Update the global reference
                    window.settingsPanel = panelElement;
                }
                
                // Check if panel is currently visible - use multiple methods for robustness
                let isVisible = false;
                
                try {
                    // Method 1: Check style.display
                    if (settingsPanel.style.display === 'flex') {
                        isVisible = true;
                    }
                    
                    // Method 2: Check computed style
                    else if (getComputedStyle(settingsPanel).display !== 'none') {
                        isVisible = true;
                    }
                    
                    // Method 3: Check offsetParent
                    else if (settingsPanel.offsetParent !== null) {
                        isVisible = true;
                    }
                } catch (checkError) {
                    console.error('Error checking panel visibility:', checkError);
                }
                
                console.log('Settings panel is visible (direct check):', isVisible);
                
                // Toggle visibility
                if (isVisible) {
                    console.log('Hiding settings panel via toggleSettings');
                    settingsPanel.style.display = 'none';
                    localStorage.setItem('settingsOpen', 'false');
                } else {
                    console.log('Showing settings panel via toggleSettings');
                    settingsPanel.style.display = 'flex';
                    localStorage.setItem('settingsOpen', 'true');
                    
                    // Double-check that it worked
                    setTimeout(() => {
                        if (getComputedStyle(settingsPanel).display === 'none') {
                            console.warn('Settings panel still hidden after toggle, forcing display');
                            settingsPanel.style.cssText = 'display: flex !important';
                        }
                    }, 50);
                }
            } catch (error) {
                console.error('Error in toggleSettings function:', error);
                alert('There was an error toggling the settings panel. Please try again or reload the page.');
            }
        }
        
        // Theme switching functionality
        const themeSwitch = document.getElementById('themeSwitch');
        
        // Function to set theme
        function setTheme(isDark) {
            if (isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
                themeSwitch.checked = true;
            } else {
                document.documentElement.removeAttribute('data-theme');
                themeSwitch.checked = false;
            }
        }
        
        // Toggle theme when switch is clicked
        themeSwitch.addEventListener('change', () => {
            setTheme(themeSwitch.checked);
            localStorage.setItem('darkTheme', themeSwitch.checked);
        });
        
        // Fullscreen functionality
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        const container = document.querySelector('.container');
        let isFullscreen = false;
        let fullscreenExitBtn = null;
        
        // Function to enter fullscreen mode
        function enterFullscreen() {
            console.log('Entering fullscreen mode');
            
            // Add fullscreen class to container
            container.classList.add('fullscreen-mode');
            
            // Create exit fullscreen button
            fullscreenExitBtn = document.createElement('button');
            fullscreenExitBtn.className = 'fullscreen-exit';
            fullscreenExitBtn.innerHTML = '⬉ Exit Fullscreen';
            fullscreenExitBtn.addEventListener('click', exitFullscreen);
            container.appendChild(fullscreenExitBtn);
            
            // Hide settings panel if open
            if (settingsPanel.style.display !== 'none') {
                hideSettings();
            }
            
            // Update button text
            fullscreenBtn.textContent = '⛶ Exit Fullscreen';
            
            // Use Fullscreen API if available
            if (container.requestFullscreen) {
                container.requestFullscreen().catch(err => {
                    console.error('Error attempting to enable fullscreen:', err);
                });
            } else if (container.mozRequestFullScreen) { // Firefox
                container.mozRequestFullScreen();
            } else if (container.webkitRequestFullscreen) { // Chrome, Safari, Opera
                container.webkitRequestFullscreen();
            } else if (container.msRequestFullscreen) { // IE/Edge
                container.msRequestFullscreen();
            }
            
            isFullscreen = true;
            localStorage.setItem('isFullscreen', 'true');
        }
        
        // Function to exit fullscreen mode
        function exitFullscreen() {
            console.log('Exiting fullscreen mode');
            
            // Remove fullscreen class from container
            container.classList.remove('fullscreen-mode');
            
            // Remove exit fullscreen button
            if (fullscreenExitBtn) {
                fullscreenExitBtn.remove();
                fullscreenExitBtn = null;
            }
            
            // Update button text
            fullscreenBtn.textContent = '⛶ Enter Fullscreen';
            
            // Exit fullscreen using API if needed
            if (document.fullscreenElement || 
                document.webkitFullscreenElement || 
                document.mozFullScreenElement ||
                document.msFullscreenElement) {
                
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) { // Firefox
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) { // Chrome, Safari, Opera
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { // IE/Edge
                    document.msExitFullscreen();
                }
            }
            
            isFullscreen = false;
            localStorage.setItem('isFullscreen', 'false');
        }
        
        // Toggle fullscreen when button is clicked
        fullscreenBtn.addEventListener('click', () => {
            if (isFullscreen) {
                exitFullscreen();
            } else {
                enterFullscreen();
            }
        });
        
        // Handle fullscreen change events
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        
        function handleFullscreenChange() {
            // If user exits fullscreen using browser controls (Esc key)
            if (!document.fullscreenElement && 
                !document.webkitFullscreenElement && 
                !document.mozFullScreenElement &&
                !document.msFullscreenElement && 
                isFullscreen) {
                
                exitFullscreen();
            }
        }
        
        // Load fullscreen state from localStorage
        function loadFullscreenState() {
            const savedFullscreen = localStorage.getItem('isFullscreen') === 'true';
            if (savedFullscreen) {
                enterFullscreen();
            }
        }
        
        // Debug panel functionality
        const debugSwitch = document.getElementById('debugSwitch');
        const debugPanel = document.getElementById('debugPanel');
        const resetMetricsBtn = document.getElementById('resetMetricsBtn');
        
        // Debug metrics elements
        const scheduledBeatsEl = document.getElementById('scheduledBeats');
        const playedBeatsEl = document.getElementById('playedBeats');
        const missedBeatsEl = document.getElementById('missedBeats');
        const avgLatencyEl = document.getElementById('avgLatency');
        const serverOffsetEl = document.getElementById('serverOffset');
        
        // Toggle debug panel when debug switch is clicked
        debugSwitch.addEventListener('change', () => {
            debugPanel.style.display = debugSwitch.checked ? 'block' : 'none';
            
            // Start or stop metrics update interval
            if (debugSwitch.checked) {
                startMetricsUpdate();
            } else {
                stopMetricsUpdate();
            }
            
            // Save debug state to settings
            saveSettings();
        });
        
        // Reset metrics when reset button is clicked
        resetMetricsBtn.addEventListener('click', () => {
            timingMetrics.reset();
            updateMetricsDisplay();
            console.log('Timing metrics reset');
        });
        
        // Metrics update interval
        let metricsUpdateInterval = null;
        
        // Start periodic metrics update
        function startMetricsUpdate() {
            if (metricsUpdateInterval) return;
            
            // Update immediately
            updateMetricsDisplay();
            
            // Then update every 500ms
            metricsUpdateInterval = setInterval(updateMetricsDisplay, 500);
            console.log('Metrics update started');
        }
        
        // Stop periodic metrics update
        function stopMetricsUpdate() {
            if (metricsUpdateInterval) {
                clearInterval(metricsUpdateInterval);
                metricsUpdateInterval = null;
                console.log('Metrics update stopped');
            }
        }
        
        // Update metrics display
        function updateMetricsDisplay() {
            scheduledBeatsEl.textContent = timingMetrics.scheduledBeats;
            playedBeatsEl.textContent = timingMetrics.playedBeats;
            missedBeatsEl.textContent = timingMetrics.missedBeats;
            
            // Format average latency to 2 decimal places
            const avgLatency = timingMetrics.getAverageLatency();
            avgLatencyEl.textContent = `${avgLatency.toFixed(2)} ms`;
            
            // Format server offset to 2 decimal places
            const offsetMs = serverTimeOffset * 1000;
            serverOffsetEl.textContent = `${offsetMs.toFixed(2)} ms`;
        }
        
        // Save settings to localStorage
        function saveSettings() {
            const settings = {
                currentSound: soundSettings.currentSound,
                volume: soundSettings.volume,
                muted: soundSettings.muted,
                latencyOffset: soundSettings.latencyOffset,
                darkTheme: themeSwitch.checked,
                debugEnabled: debugSwitch.checked
            };
            localStorage.setItem('metronomeSettings', JSON.stringify(settings));
            console.log('Settings saved to localStorage:', settings);
        }
        
        // Load settings from localStorage
        function loadSettings() {
            console.log('Loading settings from localStorage...');
            
            // Skip loading if settings have already been loaded by loadSettingsImmediately
            if (settingsAlreadyLoaded) {
                console.log('Settings already loaded immediately, skipping loadSettings');
                
                // Just check if settings panel should be open
                const settingsOpen = localStorage.getItem('settingsOpen') === 'true';
                if (settingsOpen) {
                    console.log('Settings panel should be open, showing it');
                    setTimeout(() => {
                        try {
                            showSettings();
                        } catch (e) {
                            console.error('Error showing settings panel:', e);
                        }
                    }, 100);
                }
                
                return;
            }
            
            console.log('Settings not loaded yet, loading from loadSettings');
            
            // First check for standalone theme setting (for backward compatibility)
            const darkTheme = localStorage.getItem('darkTheme') === 'true';
            setTheme(darkTheme);
            
            const savedSettings = localStorage.getItem('metronomeSettings');
            if (savedSettings) {
                try {
                    const settings = JSON.parse(savedSettings);
                    console.log('Loading settings from localStorage:', settings);
                    
                    // Update sound settings
                    if (settings.currentSound) {
                        soundSettings.currentSound = settings.currentSound;
                        clickSoundSelect.value = settings.currentSound;
                    }
                    
                    if (settings.volume !== undefined) {
                        soundSettings.volume = settings.volume;
                        volumeControl.value = settings.volume;
                    }
                    
                    if (settings.muted !== undefined) {
                        soundSettings.muted = settings.muted;
                        muteBtn.textContent = soundSettings.muted ? '🔇 Off' : '🔊 On';
                        muteBtn.classList.toggle('muted', soundSettings.muted);
                    }
                    
                    if (settings.latencyOffset !== undefined) {
                        soundSettings.latencyOffset = settings.latencyOffset;
                        const offsetMs = Math.round(settings.latencyOffset * 1000);
                        latencyOffsetControl.value = offsetMs;
                        offsetValueDisplay.textContent = `${offsetMs} ms`;
                    }
                    
                    // Apply theme setting from saved settings
                    if (settings.darkTheme !== undefined) {
                        console.log('Applying theme from saved settings');
                        setTheme(settings.darkTheme);
                    }
                    
                    // Apply debug panel state from saved settings
                    if (settings.debugEnabled !== undefined && debugSwitch && debugPanel) {
                        console.log('Applying debug panel state from saved settings:', settings.debugEnabled);
                        debugSwitch.checked = settings.debugEnabled;
                        debugPanel.style.display = settings.debugEnabled ? 'block' : 'none';
                        
                        // Start metrics update if debug panel is enabled
                        if (settings.debugEnabled) {
                            startMetricsUpdate();
                        }
                    }
                } catch (error) {
                    console.error('Error loading settings from localStorage:', error);
                }
            }
            
            // Check if settings panel should be open
            const settingsOpen = localStorage.getItem('settingsOpen') === 'true';
            console.log('Settings panel should be open:', settingsOpen);
            
            // Ensure settings panel exists and has proper initial state
            try {
                // Try to get the settings panel again in case it wasn't available earlier
                const panelElement = document.getElementById('settingsPanel');
                
                if (panelElement) {
                    console.log('Settings panel found during loadSettings');
                    
                    // Update the global reference if needed
                    if (!settingsPanel) {
                        console.log('Updating global settingsPanel reference');
                        window.settingsPanel = panelElement;
                    }
                    
                    // Force initial state to be hidden
                    panelElement.style.display = 'none';
                    console.log('Forced settings panel display to none during loadSettings');
                    
                    // Then show if needed, with a longer delay to ensure DOM is fully ready
                    if (settingsOpen) {
                        console.log('Will open settings panel during initialization');
                        setTimeout(() => {
                            try {
                                console.log('Delayed opening of settings panel');
                                showSettings();
                                
                                // Double-check after a short delay
                                setTimeout(() => {
                                    try {
                                        if (getComputedStyle(panelElement).display === 'none') {
                                            console.warn('Settings panel still hidden after delayed open, forcing display');
                                            panelElement.style.cssText = 'display: flex !important';
                                        }
                                    } catch (e) {
                                        console.error('Error in double-check after delayed open:', e);
                                    }
                                }, 100);
                            } catch (e) {
                                console.error('Error in delayed opening of settings panel:', e);
                            }
                        }, 1000); // Longer delay to ensure DOM is fully ready
                    }
                } else {
                    console.error('Settings panel not found during loadSettings, even after retry');
                }
            } catch (error) {
                console.error('Error handling settings panel in loadSettings:', error);
            }
        }
        
        // Update theme switch event listener to save all settings
        themeSwitch.addEventListener('change', () => {
            setTheme(themeSwitch.checked);
            saveSettings();
        });
        
        // Update event listeners to save settings
        clickSoundSelect.addEventListener('change', () => {
            soundSettings.currentSound = clickSoundSelect.value;
            saveSettings();
        });
        
        volumeControl.addEventListener('input', () => {
            soundSettings.volume = parseFloat(volumeControl.value);
            saveSettings();
        });
        
        muteBtn.addEventListener('click', () => {
            soundSettings.muted = !soundSettings.muted;
            muteBtn.textContent = soundSettings.muted ? '🔇 Off' : '🔊 On';
            muteBtn.classList.toggle('muted', soundSettings.muted);
            saveSettings();
        });
        
        latencyOffsetControl.addEventListener('input', () => {
            const offsetMs = parseInt(latencyOffsetControl.value);
            soundSettings.latencyOffset = offsetMs / 1000; // Convert ms to seconds
            offsetValueDisplay.textContent = `${offsetMs} ms`;
            
            // Log the change
            console.log(`Latency offset set to ${offsetMs} ms`);
            saveSettings();
        });
        
        // Initialize sounds and connection
        async function initialize() {
            console.log('Initializing application...');
            
            try {
                // Connect to WebSocket server first to ensure immediate connection
                console.log('Connecting to WebSocket server during initialization...');
                connectWebSocket();
                
                console.log('Audio context state:', audioContext.state);
                
                // Try to resume audio context immediately (might work if user has interacted)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                    console.log('Audio context resumed during initialization');
                }
                
                // Load saved settings
                loadSettings();
                
                // Load fullscreen state
                loadFullscreenState();
                
                // Preload sounds after connection and settings are loaded
                await preloadSounds();
                
                // Set a global fallback timer to force mock server mode if connection hangs
                if (globalFallbackTimer) {
                    clearTimeout(globalFallbackTimer);
                }
                
                globalFallbackTimer = setTimeout(() => {
                    console.log('Global fallback timer triggered - checking connection status');
                    
                    // If status still shows connecting, force mock server mode
                    if (statusDisplay.textContent === 'Connecting...' || 
                        statusDisplay.textContent === 'Łączenie z serwerem...') {
                        console.log('Still in connecting state after timeout - forcing mock server mode');
                        
                        // Force mock server mode
                        if (!useMockServer) {
                            useMockServer = true;
                            localStorage.setItem('useMockServer', 'true');
                            
                            // Close socket if it exists
                            if (socket) {
                                try {
                                    socket.close();
                                } catch (e) {
                                    console.error('Error closing socket in global fallback:', e);
                                }
                            }
                            
                            // Setup mock server
                            setupMockServer();
                        }
                    } else {
                        console.log('Connection status is not in connecting state:', statusDisplay.textContent);
                    }
                }, 5000); // 5 second global fallback
                
                console.log('Initialization complete. Audio context state:', audioContext.state);
                
                // Final check for settings panel functionality
                setTimeout(() => {
                    try {
                        console.log('Final settings panel check...');
                        const panel = document.getElementById('settingsPanel');
                        if (panel) {
                            const displayStyle = getComputedStyle(panel).display;
                            console.log('Settings panel final state:', {
                                element: panel,
                                displayStyle: displayStyle,
                                offsetParent: panel.offsetParent,
                                shouldBeOpen: localStorage.getItem('settingsOpen') === 'true'
                            });
                            
                            // If there's a mismatch between expected and actual state, try to fix it
                            const shouldBeOpen = localStorage.getItem('settingsOpen') === 'true';
                            const isOpen = displayStyle !== 'none' && panel.offsetParent !== null;
                            
                            if (shouldBeOpen && !isOpen) {
                                console.warn('Settings panel should be open but is not, forcing open');
                                panel.style.cssText = 'display: flex !important';
                            } else if (!shouldBeOpen && isOpen) {
                                console.warn('Settings panel should be closed but is open, forcing close');
                                panel.style.display = 'none';
                            }
                            
                            // Add a click handler directly to the settings toggle button as a final fallback
                            const toggle = document.getElementById('settingsToggle');
                            if (toggle) {
                                console.log('Adding direct click handler to settings toggle button');
                                toggle.onclick = function(e) {
                                    console.log('Settings toggle clicked via direct handler');
                                    toggleSettings();
                                    return false;
                                };
                            }
                            
                            // Add a click handler directly to the close button as a final fallback
                            const closeBtn = document.getElementById('closeSettings');
                            if (closeBtn) {
                                console.log('Adding direct click handler to close settings button');
                                closeBtn.onclick = function(e) {
                                    console.log('Close settings button clicked via direct handler');
                                    hideSettings();
                                    return false;
                                };
                            }
                        } else {
                            console.error('Settings panel not found in final check');
                        }
                    } catch (e) {
                        console.error('Error in final settings panel check:', e);
                    }
                }, 2000); // Check after 2 seconds to ensure everything is loaded
            } catch (error) {
                console.error('Error during initialization:', error);
            }
        }
        
        // Start initialization as soon as the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM fully loaded - starting initialization immediately');
            initialize();
        });
        
        // Also start initialization now in case DOMContentLoaded has already fired
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            console.log('Document already loaded - starting initialization immediately');
            initialize();
        }
        
        // Flag to track if settings have been loaded
        let settingsAlreadyLoaded = false;
        
        // Load and apply critical settings immediately, even before DOM is fully loaded
        function loadSettingsImmediately() {
            try {
                console.log('Loading critical settings immediately...');
                
                // Load saved settings
                const savedSettings = localStorage.getItem('metronomeSettings');
                let parsedSettings = null;
                
                // First check for standalone theme setting (for backward compatibility)
                const darkTheme = localStorage.getItem('darkTheme') === 'true';
                
                if (savedSettings) {
                    try {
                        parsedSettings = JSON.parse(savedSettings);
                        console.log('Parsed saved settings:', parsedSettings);
                    } catch (e) {
                        console.error('Error parsing saved settings:', e);
                    }
                }
                
                // Apply theme (prefer settings over standalone)
                const finalTheme = parsedSettings && parsedSettings.darkTheme !== undefined 
                    ? parsedSettings.darkTheme 
                    : darkTheme;
                
                console.log('Applying theme immediately, isDark:', finalTheme);
                
                if (finalTheme) {
                    document.documentElement.setAttribute('data-theme', 'dark');
                } else {
                    document.documentElement.removeAttribute('data-theme');
                }
                
                // Initialize sound settings with defaults
                if (!window.soundSettings) {
                    window.soundSettings = {
                        currentSound: 'click1',
                        volume: 0.5,
                        muted: true,
                        latencyOffset: 0.05
                    };
                }
                
                // Apply sound settings if available
                if (parsedSettings) {
                    if (parsedSettings.currentSound) {
                        window.soundSettings.currentSound = parsedSettings.currentSound;
                    }
                    
                    if (parsedSettings.volume !== undefined) {
                        window.soundSettings.volume = parsedSettings.volume;
                    }
                    
                    if (parsedSettings.muted !== undefined) {
                        window.soundSettings.muted = parsedSettings.muted;
                    }
                    
                    if (parsedSettings.latencyOffset !== undefined) {
                        window.soundSettings.latencyOffset = parsedSettings.latencyOffset;
                    }
                }
                
                // Update UI elements when they become available
                setTimeout(() => {
                    try {
                        // Update theme switch
                        const themeSwitch = document.getElementById('themeSwitch');
                        if (themeSwitch) {
                            themeSwitch.checked = finalTheme;
                        }
                        
                        // Update sound settings UI
                        const clickSoundSelect = document.getElementById('clickSound');
                        const volumeControl = document.getElementById('volume');
                        const muteBtn = document.getElementById('muteBtn');
                        const latencyOffsetControl = document.getElementById('latencyOffset');
                        const offsetValueDisplay = document.getElementById('offsetValue');
                        
                        if (clickSoundSelect && window.soundSettings.currentSound) {
                            clickSoundSelect.value = window.soundSettings.currentSound;
                        }
                        
                        if (volumeControl && window.soundSettings.volume !== undefined) {
                            volumeControl.value = window.soundSettings.volume;
                        }
                        
                        if (muteBtn && window.soundSettings.muted !== undefined) {
                            muteBtn.textContent = window.soundSettings.muted ? '🔇 Off' : '🔊 On';
                            muteBtn.classList.toggle('muted', window.soundSettings.muted);
                        }
                        
                        if (latencyOffsetControl && offsetValueDisplay && window.soundSettings.latencyOffset !== undefined) {
                            const offsetMs = Math.round(window.soundSettings.latencyOffset * 1000);
                            latencyOffsetControl.value = offsetMs;
                            offsetValueDisplay.textContent = `${offsetMs} ms`;
                        }
                        
                        console.log('UI elements updated with saved settings');
                    } catch (e) {
                        console.error('Error updating UI elements with saved settings:', e);
                    }
                }, 0);
                
                // Set flag to indicate settings have been loaded
                settingsAlreadyLoaded = true;
                
                console.log('Critical settings applied immediately');
            } catch (error) {
                console.error('Error loading settings immediately:', error);
            }
        }
        
        // Apply settings immediately
        loadSettingsImmediately();
        
        // Force WebSocket connection immediately, even before DOM is fully loaded
        // This ensures the connection is established as early as possible
        console.log('Forcing immediate WebSocket connection attempt');
        connectWebSocket();
    </script>
</body>
</html>